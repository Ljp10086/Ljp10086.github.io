[{"title":"TypeScript类型编程","url":"//2023/06/28/TypeScript%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/","content":"TypeScript的类型系统TypeScript给JavaScript增加了一套静态类型系统，通过 TS Compiler 编译为 JS，编译的过程做类型检查。\n它并没有改变 JavaScript 的语法，只是在 JS 的基础上添加了类型语法，所以被叫做 JavaScript 的超集。\nJavaScript 的标准在不断的发展，TypeScript 的类型系统也在不断完善，因为“超集”的设计理念，这两者可以很好的融合在一起，是不会有冲突的。\n静态类型编程语言都有自己的类型系统，从简单到复杂可以分为 3 类：\n简单类型系统变量、函数、类等都可以声明类型，编译器会基于声明的类型做类型检查，类型不匹配时编译器会报错。\n这是最基础的类型系统，能保证类型安全，但有些死板。\n比如一个 identify 函数，我们希望这个函数传入什么值可以原封不动的返回，如果我们想要传入的类型为 number或者string的话，我们需要这样写：\nfunction identify(x: number | string):   number | string &#123;  return x;&#125;const res123 = identify(1);\n\n如果我们还想传入boolean类型的话：\nfunction identify(x: number | string | boolean):   number | string | boolean &#123;  return x;&#125;const res123 = identify(false);\n\n这样的话就会出现一个问题：每次传入一个新的类型就必须得重新修改函数的参数与返回值类型。\n如果类型能传参数就好了，传入number就会返回number，传入string就返回string。\n所以有了第二种类型系统。\n支持泛型的类型系统泛型的英文是Generic Type，译为‘通用的类型’，它可以表示任何一种类型，也可以叫类型参数。\n比如上面的例子，有了泛型之后我们可以这样写：\nfunction identify(x: T): T &#123;  return x;&#125;identify(true);identify(3.1415926);identify(&#x27;我不是string&#x27;);\n\n声明时把会变化的类型声明成泛型（也就是类型参数），在调用的时候再确定类型。\n很多语言，类如Java、Dart等用的就是这种类型系统，泛型确实是一个可以很好地增加类型系统灵活性的特性。\n但是，这种类型系统的灵活性对于 JavaScript 来说还不够，因为 JavaScript 太过灵活了。\n比如，在 Java 里，对象都是由类 new 出来的，你不能凭空创建对象，但是 JavaScript 却可以，它支持对象字面量。\n那如果是一个返回对象某个属性值的函数，类型该怎么写呢？\nfunction getPropValue(obj: T, key: string) &#123;    return obj[key];&#125;const res = getPropValue(&#123;a: 1, b: 2&#125;, &#x27;a&#x27;);\n\n\n我们可以看到类型返回值为any。\n好像拿到了T也拿不到它的属性值与属性值，如果我们可以对类型参数T做一些处理就好了。\n所以，有了第三种类型系统。\n支持类型编程的类型系统在 Java 里面，拿到了对象的类型就能找到它的类，进一步拿到各种信息，所以类型系统支持泛型就足够了。\n但是在 JavaScript 里面，对象可以字面量的方式创建，还可以灵活的增删属性，拿到对象并不能确定什么，所以要支持对传入的类型参数做进一步的处理。\n对传入的类型参数（泛型）做各种逻辑运算，产生新的类型，这就是类型编程。\n比如上面那个 getProps 的函数，类型可以这样写：\nfunction getPropValue&lt;T extends object, Key extends keyof T&gt;(  obj: T, key: Key): T[Key] &#123;    return obj[key];&#125;const res1 = getPropValue(&#123;a: 1, b: 2&#125;, &#x27;a&#x27;);\n\n\n这里我们成功地拿到了返回值的类型！\n这里的 keyof T、T[Key] 就是对类型参数 T 的类型运算。\nTypeScript 的类型系统就是第三种，支持对类型参数做各种逻辑处理，可以写很复杂的类型逻辑。\n类型逻辑能有多复杂？\n类型逻辑是对类型参数的各种处理，可以实现很多强大的功能。\n\n比如这个 ParseQueryString 的类型：\n\n它可以对传入的字符串的类型参数做解析，返回解析以后的结果。\n如果是一些只支持泛型的类型系统是不能做到这一点的。但是 TypeScript 的类型系统就可以，因为它可以对泛型（类型参数）做各种逻辑处理。\n只不过，这个类型的类型逻辑的代码比较多：\n\n下面的 ts 类型暂时看不懂没关系，这里只是展示一下TS类型编程的复杂度，相信大家在看完这篇文章之后也可以实现这样的复杂类型。\n\ntype ParseParam =     Param extends `$&#123;infer Key&#125;=$&#123;infer Value&#125;`        ? &#123;            [K in Key]: Value         &#125; : &#123;&#125;;type MergeValues =     One extends Other         ? One        : Other extends unknown[]            ? [One, ...Other]            : [One, Other];type MergeParams&lt;    OneParam extends Record,    OtherParam extends Record&gt; = &#123;  [Key in keyof OneParam | keyof OtherParam]:     Key extends keyof OneParam        ? Key extends keyof OtherParam            ? MergeValues            : OneParam[Key]        : Key extends keyof OtherParam             ? OtherParam[Key]             : never&#125;type ParseQueryString =     Str extends `$&#123;infer Param&#125;&amp;$&#123;infer Rest&#125;`        ? MergeParams, ParseQueryString&gt;        : ParseParam;\n\n对类型参数的编程是 TypeScript 类型系统最强大的部分，可以实现各种复杂的类型计算逻辑，是它的优点。但同时也被认为是它的缺点，因为除了业务逻辑外还要写很多类型逻辑。\n不过，我倒是觉得这种复杂度是不可避免的，因为 JS 本身足够灵活，要准确定义类型那类型系统必然也要设计的足够灵活。\nTypeScript类型系统中的类型静态类型系统的目的是把类型检查从运行时提前到编译时，那 TS 类型系统中肯定要把 JS 的运行时类型拿过来，也就是 number、boolean、string、object、bigint、symbol、undefined、null 这些类型，还有就是它们的包装类型 Number、Boolean、String、Object、Symbol。\n引用类型方面，JS 有 class、Array，这些 TypeScript 类型系统也都支持，但是又多加了三种类型：元组（Tuple）、接口（Interface）、枚举（Enum）。\n元组元组(Tuple)就是元素个数和类型固定的数组类型：\ntype Tuple = [number, string];\n\n接口接口(Interface)可以描述对象、函数、构造器的结构：\n对象interface IPerson &#123;    name: string;    age: number;&#125;class Person implements IPerson &#123;    name: string;    age: number;&#125;const obj: IPerson = &#123;    name: &#x27;h&#x27;,    age: 18&#125;\n\n函数interface SayHello &#123;    (name: string): string;&#125;const func: SayHello = (name: string) =&gt; &#123;    return &#x27;hello,&#x27; + name&#125;\n\n构造器interface PersonConstructor &#123;    new (name: string, age: number): IPerson;&#125;function createPerson(ctor: PersonConstructor): IPerson &#123;    return new ctor(&#x27;a&#x27;, 18);&#125;\n\n对象类型、class 类型在 TypeScript 里也叫做索引类型，也就是索引了多个元素的类型的意思。对象可以动态添加属性，如果不知道会有什么属性，可以用可索引签名：\ninterface IPerson &#123;    [prop: string]: string | number;&#125;const obj: IPerson = &#123;&#125;;obj.name = &#x27;i&#x27;;obj.age = 18;\n\n总之，接口可以用来描述函数、构造器、索引类型（对象、class、数组）等复合类型。\n枚举枚举（Enum）是一系列值的复合：\nenum Transpiler &#123;    Babel = &#x27;babel&#x27;,    Postcss = &#x27;postcss&#x27;,    Terser = &#x27;terser&#x27;,    Prettier = &#x27;prettier&#x27;,    TypeScriptCompiler = &#x27;tsc&#x27;&#125;const transpiler = Transpiler.TypeScriptCompiler;\n\n此外，TypeScript 还支持字面量类型，也就是类似 1111、&#39;aaaa&#39;、&#123; a: 1 &#125; 这种值也可以做为类型。\n还有四种特殊的类型：void、never、any、unknown：\n\nvoid 代表空，可以是 null 或者 undefined，一般是用于函数返回值。\nany 是任意类型，任何类型都可以赋值给它，它也可以赋值给任何类型（除了 never）。\nunknown 是未知类型，任何类型都可以赋值给它，但是它不可以赋值给别的类型。\nnever 代表不可达，比如函数抛异常的时候，返回值就是 never。\n\n这些就是 TypeScript 类型系统中的全部类型了，大部分是从 JS 中迁移过来的，比如基础类型、- Array、class 等，也添加了一些类型，比如 枚举（enum）、接口（interface）、元组等，还支持了字面量类型和 void、never、any、unknown 的特殊类型。\n类型的装饰TypeScript还支持描述类型的属性，比如是否可选，是否只读等：\ninterface IPerson &#123;    readonly name: string;    age?: number;&#125;type tuple = [string, number?];\n\n接下来我们进入一个重点，大家以后去解包一些类型都是以下一章讲的这些Api为基础来进行的。\nTypeScript 类型系统中的类型运算条件类型: extends ?条件类型语法类似与JS的三元表达式：\ntype res = 1 extends 2 ? true : false;type isTwo = T extends 2 ? true: false;type res1 = isTwo&lt;1&gt;;type res2 = isTwo&lt;2&gt;;\n\n结果\n\n这种类型也叫高级类型\n高级类型的特点是传入类型参数，经过运算之后返回一个新的类型。\n推导类型: infer推导类型的关键字为infer，作用类似与是声明一个局部变量，获取类型的某一部分。\n例，获取元组中第一个属性的类型：\ntype First = Tuple extends [infer T, ...unknown[]] ? T : never;type res = First&lt;[1, 2, 3]&gt;;\n\nres类型为：\n\n注意：这里的在等式左边有一个Tuple extends unknown[]这里的extends关键字并不是条件类型，条件类型是：extends ? :，这里的意思是约束类型参数（泛型）只能是数组类型。\nPS：因为不知道数组元素的具体类型，所以使用unknown。\n联合类型: |联合类型（Union）类似 js 里的或运算符 |，但是作用于类型，代表类型可以是几个类型之一。\ntype Union = 1 | 2 | 3;\n\n交叉类型: &amp;交叉类型（Intersection）类似 js 中的与运算符 &amp;，但是作用于类型，代表对类型做合并。\ntype ObjType = &#123;a: number &#125; &amp; &#123;c: boolean&#125;;\n\n\n注意：同一类型可以合并，不同的类型没法合并，会被舍弃：\n\n映射类型对象、class在TypeScript对应的类型是索引类型，那么如何对索引类型修改呢？\n答案就是映射类型。\ntype MapType = &#123;  [Key in keyof T]?: T[Key]&#125;\n\n其中涉及到三个关键字：\n\nkeyof T 是查询索引类型中所有的索引，叫做索引查询。\nT[Key] 是取索引类型某个索引的值，叫做索引访问。\nin 是用于遍历联合类型的运算符。\n\n比如我们把一个索引类型的值变成一个字符串：\ntype MapType = &#123;    [Key in keyof T]: &#x27;hello world&#x27;&#125;type res = MapType&lt;&#123;a: 1, b: 2&#125;&gt;;\n\n\n映射类型就相当于把一个集合映射到另一个集合，这是它名字的由来。\n除了值可以变化，索引也可以变化：\ntype MapType = &#123;    [        Key in keyof T             as `$&#123;Key &amp; string&#125; qq`    ]: T[Key]  &#125;;type res = MapType&lt;&#123;&#x27;1&#x27;: 1, &#x27;2&#x27;: 2&#125;&gt;;\n\n\n我们用 as 把索引也做了修改，改成了原本的Key后加一个‘ qq’\n小结给 JavaScript 添加静态类型系统，那肯定是能复用的就复用，所以在 TypeScript 里，基础类型和 class、Array 等复合类型都是和 JavaScript 一样的，只是又额外加了接口（interface）、枚举（enum）、元组这三种复合类型（对象类型、class 类型在 TypeScript 里叫做索引类型），还有 void、never、any、unkown 四种特殊类型，以及支持字面量做为类型。此外，TypeScript 类型系统也支持通过 readonly、？等修饰符对属性的特性做进一步的描述。\n此外，TypeScript 支持对类型做运算，这是它的类型系统的强大之处，也是复杂之处。\nTypeScript 支持条件、推导、联合、交叉等运算逻辑，还有对联合类型做映射。\n这些逻辑是针对类型参数，也就是泛型（类型参数）来说的，传入类型参数，经过一系列类型运算逻辑后，返回新的类型的类型就叫做高级类型，如果是静态的值，直接算出结果即可，没必要写类型逻辑。\n这些语法看起来没有多复杂，但是他们却可以实现很多复杂逻辑，就像 JS 的语法也不复杂，却可以实现很多复杂逻辑一样。\n后面我们会大量用到这些类型编程语法来实现各种复杂的类型逻辑。\n编写类型技巧\nTypeScript 类型编程的代码看起来比较复杂，但其实这些逻辑用 JS 大家都会写，之所以到了类型体操就不会了，那是因为还不熟悉一些套路。所以，这节开始我们就来学习一些类型编程的套路，熟悉这些套路之后，各种类型体操逻辑就能够很顺畅的写出来。\n\n首先，我们来学习类型编程的第一个套路：模式匹配。\n模式匹配我们知道，字符串可以和正则做模式匹配，找到匹配的部分，提取子组，之后可以用 1,1,2 等引用匹配的子组。\nTypescript 的类型也同样可以做模式匹配。\n比如这样一个 Promise 类型：\ntype p = Promise&lt;&#x27;haha&#x27;&gt;;\n\n我们想提取 value 的类型，可以这样做：\ntype GetValueType = P extends Promise ? Value : never;\n\n通过 extends 对传入的类型参数 P 做模式匹配，其中值的类型是需要提取的，通过 infer 声明一个局部变量 Value 来保存，如果匹配，就返回匹配到的 Value，否则就返回 never 代表没匹配到。\n\n这就是 Typescript 类型的模式匹配：\nTypescript 类型的模式匹配是通过 extends 对类型参数做匹配，结果保存到通过 infer 声明的局部类型变量里，如果匹配就能从该局部变量里拿到提取出的类型。\n这个模式匹配的套路有多有用呢？我们来看下在数组、函数等类型里的应用。\n数组Last前几章我们介绍了获取数组第一个元素的First，既然可以提取第一个元素，当然也可以提取最后一个元素，修改下模式类型就行：\ntype arr = [1,2,3]type Last = T extends [...unknown[], infer U] ? U : never;type Ans = Last;\n\n\n函数GetParameters类型参数 Func 是要匹配的函数类型，通过 extends 约束为 Function。\nFunc 和模式类型做匹配，参数类型放到用 infer 声明的局部变量 T 里，返回值可以是任何类型。\n返回提取到的参数类型 AnsFunc\ntype GetParameters = Func extends (...args: infer T)=&gt; any ? T : never;type AnsFunc = GetParameters&lt;(a: number, b: string) =&gt; void&gt;; \n\n\nGetReturnType能提取参数类型，同样也可以提取返回值类型：\ntype GetReturnType =     Func extends (...args: any[]) =&gt; infer ReturnType         ? ReturnType : never;type AnsRT = GetReturnType&lt;(a: number, b: string) =&gt; number | string&gt;;\n\nFunc 和模式类型做匹配，提取返回值到通过 infer 声明的局部变量 ReturnType 里返回。\n参数类型可以是任意类型，也就是 any[]（注意，这里不能用 unknown，因为参数类型是要赋值给别的类型的，而 unknown 只能用来接收类型，所以用 any）。\n\n重新构造类型编程主要的目的就是对类型做各种转换，那么如何对类型做修改呢？\nTypeScript 类型系统支持 3 种可以声明任意类型的变量： type、infer、类型参数。\ntype 叫做类型别名，其实就是声明一个变量存储某个类型：\ntype ttt = Promise;\n\ninfer 用于类型的提取，然后存到一个变量里，相当于局部变量：\ntype GetValueType = P extends Promise ? Value : never;\n\n类型参数用于接受具体的类型，在类型运算中也相当于局部变量：\ntype isTwo = T extends 2 ? true: false;\n\n但是，严格来说这三种也都不叫变量，因为它们不能被重新赋值。\nTypeScript 设计可以做类型编程的类型系统的目的就是为了产生各种复杂的类型，那不能修改怎么产生新类型呢？\n答案是重新构造。\n数组Push有这样一个元组类型：\ntype tuple = [1,2,3];\n\n我想给这个元组类型再添加一些类型，怎么做呢？\nTypeScript 类型变量不支持修改，我们可以构造一个新的元组类型：\ntype Push = [...Arr, Ele];\n\n类型参数 Arr 是要修改的数组&#x2F;元组类型，元素的类型任意，也就是 unknown。\n类型参数 Ele 是添加的元素的类型。\n返回的是用 Arr 已有的元素加上 Ele 构造的新的元组类型。\n\n字符串CapitalizeStr我们想把一个字符串字面量类型的 &#39;hello&#39; 转为首字母大写的 ‘Hello’。\n需要用到字符串类型的提取和重新构造：\ntype CapitalizeStr =     Str extends `$&#123;infer First&#125;$&#123;infer Rest&#125;`         ? `$&#123;Uppercase&#125;$&#123;Rest&#125;` : Str;type AnsStr = CapitalizeStr&lt;&#x27;hello&#x27;&gt;;\n\n我们声明了类型参数 Str 是要处理的字符串类型，通过 extends 约束为 string。\n通过 infer 提取出首个字符到局部变量 First，提取后面的字符到局部变量 Rest。\n然后使用 TypeScript 提供的内置高级类型 Uppercase 把首字母转为大写，加上 Rest，构造成新的字符串类型返回。\n\n特性TypeScript 类型系统中有些类型比较特殊，比如 any、never、联合类型，比如 class 有 public、protected、private 的属性，比如索引类型有具体的索引和可索引签名，索引还有可选和非可选。。。\n如果给我们一种类型让我们判断是什么类型，应该怎么做呢？\nIsAny如何判断一个类型是 any 类型呢？要根据它的特性来：\nany 类型与除never之外的任何类型的交叉都是 any，也就是 1 &amp; any 结果是 any。\n所以，可以这样写：\ntype IsAny = &#x27;T&#x27; extends (&#x27;S&#x27; &amp; T) ? true : false\n\n这里的 &#39;T&#39; 和 &#39;S&#39; 可以换成任意类型。\n当传入 any 时：\n当传入其他类型时：\nIsNevernever 在条件类型中也比较特殊，如果条件类型左边是类型参数，并且传入的是 never，那么直接返回 never：\ntype TestNever = T extends never ? true : false;\n\n当 T 为 never 时：\n\n所以，要判断 never 类型，就不能直接 T extends never，可以这样写：\ntype IsNever = [T] extends [never] ? true : false\n\n这样就能正常判断 never 类型了：\n\nGetOptional如何提取索引类型中的可选索引呢？\n这也要利用可选索引的特性：可选索引的值为 undefined 和值类型的联合类型。\n过滤可选索引，就要构造一个新的索引类型，过程中做过滤：\ntype GetOptional&gt; = &#123;    [        Key in keyof Obj             as &#123;&#125; extends Pick ? Key : never    ] : Obj[Key];&#125;type res = GetOptional&lt;&#123;a?: 1, b: 2&#125;&gt;;\n\n类型参数 Obj 为待处理的索引类型，类型约束为索引为 string、值为任意类型的索引类型 Record&lt;string, any&gt;。\n用映射类型的语法重新构造索引类型，索引是之前的索引也就是 Key in keyof Obj，但要做一些过滤，也就是 as 之后的部分。\n过滤的方式就是单独取出该索引之后，判断空对象是否是其子类型。\n这里的 Pick 是 ts 提供的内置高级类型，就是取出某个 Key 构造新的索引类型：\ntype Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P]; &#125;\n\n因为 a 可能为 undefined，也就是索引类型可能是 &#123;&#125;，所以 &#123;&#125; extends Pick&lt;Obj, Key&gt; 就能过滤出可选索引。（可选的意思就是有或者没有，没有的时候就是空的索引类型）\n值的类型依然是之前的，也就是 Obj[Key]。\n这样，就能过滤出所有可选索引，构造成新的索引类型：\n\nTypeScript内置高级类型ParametersParameters 用于提取函数类型的参数类型。\n源码是这样的：\ntype Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never;\n\n类型参数 T 为待处理的类型，通过 extends 约束为函数，参数和返回值任意。\n通过 extends 匹配一个模式类型，提取参数的类型到 infer 声明的局部变量 P 中返回。\n这样就实现了函数参数类型的提取：\n\nReturnTypeReturnType 用于提取函数类型的返回值类型。\n源码是这样的：\ntype ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;\n\n类型参数 T 为待处理的类型，通过 extends 约束为函数类型，参数和返回值任意。\n用 T 匹配一个模式类型，提取返回值的类型到 infer 声明的局部变量 R 里返回。\n这样就实现了函数返回值类型的提取：\n\nConstructorParameters构造器类型和函数类型的区别就是可以被 new。\nParameters 用于提取函数参数的类型，而 ConstructorParameters 用于提取构造器参数的类型。\n源码是这样的：\ntype ConstructorParameters&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: infer P) =&gt; any ? P : never;\n\n类型参数 T 是待处理的类型，通过 extends 约束为构造器类型，加个 abstract 代表不能直接被实例化（其实不加也行）。\n用 T 匹配一个模式类型，提取参数的部分到 infer 声明的局部变量 P 里，返回 P。\n这样就实现了构造器参数类型的提取：\n\nPartial索引类型可以通过映射类型的语法做修改，比如把索引变为可选。\ntype Partial&lt;T&gt; = &#123;    [P in keyof T]?: T[P];&#125;;\n\n类型参数 T 为待处理的类型。\n通过映射类型的语法构造一个新的索引类型返回，索引 P 是来源于之前的 T 类型的索引，也就是 P in keyof T，索引值的类型也是之前的，也就是 T[P]。\n这样就实现了把索引类型的索引变为可选的效果：\n\nRequired可以把索引变为可选，也同样可以去掉可选，也就是 Required 类型：\ntype Required&lt;T&gt; = &#123;    [P in keyof T]-?: T[P];&#125;;\n\n类型参数 T 为待处理的类型。\n通过映射类型的语法构造一个新的索引类型，索引取自之前的索引，也就是 P in keyof T，但是要去掉可选，也就是 -?，值的类型也是之前的，就是 T[P]。\n这样就实现了去掉可选修饰的目的：\n\nReadonly同样的方式，也可以添加 readonly 的修饰：\ntype Readonly&lt;T&gt; = &#123;    readonly [P in keyof T]: T[P];&#125;;\n\n类型参数 T 为待处理的类型。\n通过映射类型的语法构造一个新的索引类型返回，索引和值的类型都是之前的，也就是 P in keyof T 和 T[P]，但是要加上 readonly 的修饰。\n这样就实现了加上 readonly 的目的：\n\n总结虽然很多常用的高级类型TS已经内置了，但是从我个人的角度来说并不建议去死记硬背，因为掌握了TS类型编程套路的我们有很多内置类型都是可以自己去很快实现的，我们还是需要将重点放到提高类型运算中说到的Api的使用熟练度上来。\n在这里也给大家推荐一个很好用的练习网站：\nhttps://github.com/type-challenges/type-challenges/blob/master/README.zh-CN.md\n"},{"title":"浅谈移动端","url":"//2023/06/28/%E6%B5%85%E8%B0%88%E7%A7%BB%E5%8A%A8%E7%AB%AF/","content":"\n前言最近从零到一走完了App从开发到部署的流程，期间有调研很多移动端技术以及App部署的解决方案，借此机会分享给大家的。\n移动端技术发展史智能手机操作系统\n智能手机，是指像个人电脑一样，具有独立的操作系统，独立的运行空间，可以由用户自行安装软件、游戏、导航等第三方服务商提供的程序，并可以通过移动通讯网络来实现无线网络接入的手机类型的总称。目前智能手机的发展趋势是充分加入了人工智能、5G等多项专利技术，使智能手机成为了用途最为广泛的专利产品。\n\n塞班(Symbian) 系统虽然现在塞班系统已经Over了，但当年塞班系统是当之无愧的王者，根本就没有一个与之匹配的对手。\n\n2008年12月2日，塞班公司被诺基亚收购。\n2011年12月21日，诺基亚官方宣布放弃塞班品牌。由于缺乏新技术支持，塞班的市场份额日益萎缩。\n截止至2012年2月，塞班系统的全球市场占有量仅为3%。\n2012年5月27日，诺基亚彻底放弃开发塞班系统，但是服务将一直持续到2016年。\n2013年1月24日晚间，诺基亚宣布，今后将不再发布塞班系统的手机，意味着塞班这个智能手机操作系统，在长达14年的历史之后，终于迎来了谢幕。\n\n至此，塞班时代终结，一个时代的终结，必将伴随着新时代的到来。\nWindows PhoneWindows Phone(简称为WP)是微软于2010年10月21日正式发布的一款手机操作系统，初始版本命名为Windows Phone7.0。\n\n2011年9月27日，微软发布升级版Windows Phone 7.5，这是首个支持简体中文的系统版本。\n2012年6月21日，微软正式发布Windows Phone 8，全新的Windows Phone 8舍弃了老旧Windows CE内核，采用了与Windows系统相同的Windows NT内核，支持很多新的特性。由于内核的改变，所有Windows Phone 7.5系统的手机都将无法升级至Windows Phone 8。\n2015年1月22日，微软将Windows Phone 10更名为Windows 10 for Phone。\n2015年5月14日，微软官网正式将智能手机上的版本命名为“Windows 10 Mobile” 。\n2019年12月10日，微软停止对Windows 10 Mobile的支持。\n\n2019年12月10日这一天，微软宣布停止对Windows 10 Mobile的支持，也就宣告Windows 10 Mobile告别了历史的舞台。\nAndroidAndroid系统大家都非常熟悉了，毕竟是当前市场份额最大的移动操作系统，看一下Android的发展历程：\n-2003年10月，Andy Rubin等人创建Android公司，并组建Android团队。\n-2005年8月17日，Google低调收购了成立仅22个月的高科技企业Android及其团队。安迪鲁宾成为Google公司工程部副总裁，继续负责Android项目。\n-2008年，在GoogleI&#x2F;O大会上，谷歌提出了AndroidHAL架构图，在同年8月18号，Android获得了美国联邦通信委员会（FCC）的批准，在2008年9月，谷歌正式发布了Android 1.0系统，这也是Android系统最早的版本。\n-2009年4月，谷歌正式推出了Android 1.5这款手机，从Android 1.5版本开始，谷歌开始将Android的版本以甜品的名字命名，Android 1.5命名为Cupcake。\n-2010年10月，谷歌宣布Android系统达到了第一个里程碑，即电子市场上获得官方数字认证的Android应用数量已经达到了10万个，Android系统的应用增长非常迅速。\n-2011年8月2日，Android手机已占据全球智能机市场48%的份额，并在亚太地区市场占据统治地位，终结了塞班系统的霸主地位，跃居全球第一。\nIOSiOS是由苹果公司开发的移动操作系统 。苹果公司最早于2007年1月9日的Macworld大会上公布这个系统，其发展历程如下：\n\n2007年10月17日，苹果公司发布了第一个本地化iPhone应用程序开发包（SDK），并且计划在2月发送到每个开发者以及开发商手中。\n2010年6月，苹果公司将“iPhone OS”改名为“iOS”，同时还获得了思科iOS的名称授权。\n2010年第四季度，苹果公司的iOS占据了全球智能手机操作系统26%的市场份额。\n2013年6月10日，苹果公司在WWDC 2013上发布了iOS 7，几乎重绘了所有的系统App，去掉了所有的仿实物化，整体设计风格转为扁平化设计。将于2013年秋正式开放下载更新。\n2016年9月14日，苹果发布iOS 10正式版，这是苹果推出移动操作系统以来最大的一次更新，尤其增加了很多特别适应中国国情的功能，比如骚扰电话识别、苹果地图进一步本地化等。\n2018年9月13日，2018苹果秋季新品发布会上，苹果CEO库克介绍了苹果生态的一些数据。他表示，搭载苹果iOS系统设备已达20亿部。\n2020年5月21日，苹果发布iOS 13.5正式版，iOS 13.5加快了配备面容ID的设备在用户佩戴口罩时显示密码栏的速度，并加入了“暴露通知”API以支持来自公共卫生管理机构的COVID-19接触追踪App。\n\n移动端开发技术演进\n2008年7月IPhone推出第一代手机IPhone 3G，同年9月谷歌正式发布了Android 1.0系统，标志着我们正式步入移动端发展期，按照技术开发的历程移动端（目前特指Android和iOS）的发展大致可以分为4个阶段：Native App -&gt; Hybrid App -&gt; React Native -&gt; Flutter。\n\nNative App(原生应用)\n\n这是最为传统的一种移动端开发技术，使用Object-c&#x2F;Swift、Java&#x2F;Kotlin这些语言开发出的App一般叫做Native App。\n\n优势\n\n一般原生应用体验比较好，性能比较高，打开速度比较快。\n原生应用可以直接调用系统的Api，类似摄像头、通讯录等功能，也可以直接访问到本地资源，功能比较强大。\n\n缺点\n\n使用这种技术开发一项功能我们需要在Android和IOS两端开发，维护以及开发的成本较高。\n同时无法进行动态化更新，如果添加新功能都需要到相应的平台进行发版，尤其IOS审核周期较长，如遇到紧急问题并不能立即解决。\n\nWeb App\n\nWeb App 其实就是我们使用手机浏览器打开的网址。\n\n优势\n\n首先因为是在浏览器中运行，所以天然支持跨平台，一套代码很容易支持移动端和PC两端。\n不需要安装到用户的手机中，上线发版比较容易。\n\n缺点\n\nWeb App无法直接调用系统Api，如摄像头、相册等，局限性较大。\n比较依赖于网络，不支持离线模式，页面加载速度受限于浏览器性能，导致一些场景很难去做到原生的体验。\n\nHybrid App\n\nHybrid是综上所述的两种方式结合，一般被称为混合开发。\n\n简单来说Hybrid App就是跑到App中的网页，我们可以理解为在App中打开了一个Chrome浏览器。\n优势\n\nHybrid App 同时拥有 Native 和 Web 的优点，开发模式比较灵活。既可以做到动态化更新，有 bug 直接更新线上 H5 页面就行了。 也可以使用桥接（JS Bridge）来调用系统的摄像头、相册等功能，功能就不仅仅局限于浏览器了。\n由于 H5 的优势，Hybrid 也支持跨平台，只要有 WebView，一套代码可以很容易跨iOS、安卓、Web、小程序、快应用多个平台。\n\n缺点\n\n缺点主要还是Web App的那些缺点，性能始终突破不了浏览器的限制。\n\n实例使用Flutter来实现WebView包裹U知并且打开《Svelte，未来十年可能取代React和Vue等其他框架的新兴技术》这篇文章。\nWebView(  initialUrl:      &#x27;https://wiki.uino.com/d/svelte-simple-introduce.html&#x27;,  javascriptMode: JavascriptMode.unrestricted,  onWebViewCreated: (WebViewController c) &#123;    _controller = c;  &#125;,  javascriptChannels: &lt;JavascriptChannel&gt;[    _alertJavascriptChannel(context),  ].toSet(),  onPageFinished: (v) async &#123;    final String cookies = await _controller        .runJavascriptReturningResult(&#x27;document.cookie&#x27;);    print(cookies);    ToastManager.showSuccess(cookies);  &#125;,),\n\n手机截图：\n\n\nReact Native\nFace Book(现Meta)在研究了许久Hybrid App之后发现其性能始终需要依赖于浏览器的渲染效率，无法突破浏览器渲染的性能瓶颈，于是转而基于React发布了React Native这个框架。\n\n受制于浏览器渲染的性能，React Native 吸取经验将渲染这部分交给 Native 来做，大大提高了体验。\n\nRN 中直接使用 JavaScriptCore 来提供 JS 的运行环境，通过 Bridge 去通知 Native 绘制界面，所以最终页面是由Native绘制的，性能相较于Hybrid App要好上不少。\n但是受限于JS与Native通信的性能消耗，性能上依然不及Native。\n\nFlutter\nFlutter吸收了前面的经验，它既没有使用WebView，也没有使用原生控件进行绘制，而是自己实现了一套高性能渲染引擎来绘制UI，这个引擎就是大名鼎鼎的Skia，Skia是一个2D绘图引擎库，Chrome和Android都是采用Skia作为引擎。Flutter完美的解决了跨平台代码复用和性能问题。\n\n局限性\nFlutter并不是无所不能的，也存在一些局限性，比如\n\nUI平台一致性： 由于Flutter使用自己的引擎进行UI渲染，而不是用原生控件渲染，导致控件显示效果和原生不是完全一样。\n动态化更新： 动态化功能在国内来说是一项非常重要的功能，Google官方已经明确现阶段不会实现动态化功能。\n\n小结Flutter如此优秀那么以后是否只使用Flutter就可以了呢？笔者认为答案是否定的，在未来很长的一段时间内应该是Native App、Hybrid、React Native、Flutter共存的时代。\n\n首先原生开发时无法完全避开的，一些系统级Api必须使用原生开发。\nHybrid虽然性能有一些缺陷，但是由于其快速迭代功能的特性，依然有其适合的场景，比如一些活动页面都是使用WebView来实现的。\nReact Native可以使用原生控件渲染，因此，如果您需要使用原生控件而又想跨平台，React Native是不错的选择。\n\nApp之间通信方式总结URL Scheme\n由于手机上的沙盒机制，在保证了用户隐私安全的同时也限制了应用之间合理的信息共享，所以开发商提供了一个方法可以再App之间跳转：URL Scheme。通过该方法，可以实现App的互相调用功能。\n\n组成\n一个完整的 URL Scheme 应该分为 Scheme、Action、Parameter、Value 这 4 个部分，中间用冒号（ :）、斜线 （&#x2F;）、问号 （?）、等号（&#x3D;）相连接。举个例子：\nalipay://open?page=payPage&amp;title=pay\n\n它对应的四个部分：\n\nScheme（头）:alipay\nAction（动作）:open\nParameter（参数: page、title\nValue（值: payPage、pay\n\n大家可以尝试在浏览器中输入weixin://之后观察会发生什么。\nDeeplink\n指向某个具体内容页面的链接称为Deeplink（深度链接）。\n\n在 web 开发领域，例如 https://developer.apple.com/ 是指向某个首页的链接， https://developer.apple.com/develop/ 是指向具体内容页的链接。\n在移动端开发领域，也想做到像定位一个网页一样，用一种特殊的 URL 来定位一个应用甚至应用里某个具体的功能。\n\n定位某个应用，发挥作用的就是URL 的 scheme 部分，但是需要注意的是应用的URL scheme 并不唯一，也就是说一个应用可以“起多个名”，不同应用的URL scheme也可能因为名字一样发生冲突。\n定位到某个应用的某个具体页面，即点击一个链接后，直接链接到App内部的某个页面，而不仅仅是启动 App，要实现这一效果就需要用到deeplink。\n\ndeeplink实质上就是在URL scheme的基础上，附加了更多的信息传递给被唤起的App侧，。\nIOS上线方式总结\n\n\n\nApp Store\nIn House\nApple Business Manager\n\n\n\n分发方式\n安装包上传到App store，用户从App Store下载。\n安装包由开发者自行存储、自行分发\n安装包存储在App Store MDM、输入兑换码或者访问链接进行兑换\n\n\n可用性\n所有在Apple注册的国家或地区，公开发布\n仅限自己组织内部的员工\n69个国家与地区，私密发布\n\n\n用户要求\n公众用户\n仅限分发给自己组织内部户的员工\n定制应用组织的员工\n\n\n应用审核\n需要\n不需要\n需要（相对容易通过）\n\n\n账号申请费用\n个人或组织，99$ &#x2F; 年\n组织申请，299$ &#x2F; 年\n仅限组织申请，免费，最长五天\n\n\n典型应用场景\n分发普通大众化应用\n企业内部测试用\n1. 企业内部应用  2. 定制应用\n\n\n"},{"title":"意博趣深 - RxJS","url":"//2023/06/28/%E6%84%8F%E5%8D%9A%E8%B6%A3%E6%B7%B1%20-%20RxJS/","content":"认识RxJSReactive Extensions Library for JavaScript\n\n\nRxJS提供了一套非常完整的非同步解决方案，让我们在面对各种非同步行为时(无论是Event，AJAX亦或是Animation)，我们都可以使用相同的API来做开发。\n\n在网页的世界存取任何资源都是非同步的，比如说我们希望拿到一个档案，先发送一个请求后，必须等到数据回来，再执行对这个数据的操作，这就是一个非同步的行为。随着网页需求的复杂化，我们所写的JavaScript 就有各种针对非同步行为的写法，例如使用callback 或是Promise 物件甚至是新的语法糖async&#x2F;await —— 但随着应用需求愈来愈复杂，撰写非同步的程式码仍然非常困难。\n非同步常见的问题\n竞态危害(Race Condition)\n内存泄漏(Memory Leak)\n复杂的状态(Complex State)\n例外处理(Exception Handling)\n\nRace Condition每当我们对同一个资源同时做多次的非同步存取时，就可能发生Race Condition 的问题。比如说我们发了一个Request 更新使用者资料，然后我们又立即发送另一个Request 取得使用者资料，这时第一个Request 和第二个Request 先后顺序就会影响到最终接收到的结果不同，这就是Race Condition。\nMemory LeakMemory Leak 是最常被大家忽略的一点。原因是在传统网站的行为，我们每次换页都是整页重刷，并重新执行JavaScript，所以不太需要理会记忆体的问题！但是当我们希望将网站做得像应用程式时，这件事就变得很重要。比如说在A 页面监听body 的scroll 事件，但页面切换时，没有把scroll 的监听事件移除。\nComplex State当有非同步行为时，应用程序的状态就会变得非常复杂！比如说我们有一支付费用户才能播放的影片，首先可能要先抓取这部影片的资讯，接着我们要在播放时去验证使用者是否有权限播放，而使用者也有可能再按下播放后又立即按了取消，而这些都是非同步执行，这时就会有各种复杂的状态需要处理。\nException HandlingJavaScript 的try&#x2F;catch 可以捕捉同步的例外，但非同步的程式就没这么容易，尤其当我们的非同步行为很复杂时，这个问题就愈加明显。\n各种不同的API我们除了要面对非同步会遇到的各种问题外，还需要烦恼很多不同的API。\n\nDOM Events\nXMLHttpRequest\nFetch\nWebSockets\nServer Send Events\nService Worker\nNode Stream\nTimer\n\n上面的API都是非同步的，他们都拥有各自的API与写法！如果我们使用RxJS，上面的API都可以通过RxJS来处理，就可以使用同样的API操作(RxJS的API)。\n这里我们举一个例子，假如我们想要监听点击事件，但点击一次之后不再监听。\n原生JavaScript\nconst handler = (e) =&gt; &#123;  console.log(e);  documnet.removeEventListener(handler);&#125;document.addEventListener(&#x27;click&#x27;, handler);\n\nRxJS\nfromEvent(document, &#x27;click&#x27;)  .pipe(take(1))  .subscribe(console.log);\nstackblitz\n大致上能看得出来我们在使用RxJS后，不管是针对DOM Event还是上面列的各种API我们都可以通过RxJS的API来做操作，像是范例中使用的take(n)\nRxJS可以用于生产吗？RxJS由微软在2012年开源，目前各个语言库由ReactiveX组织维护。RxJS在GitHub上已有25.3K的start，目前最新版本为7.2，并且持续开发维护中。\nRxJS基本介绍RxJS 是 Reactive Extensions for JavaScript 的缩写，起源于 Reactive Extensions，是一个基于可观测数据流 Stream 结合观察者模式和迭代器模式的一种异步编程的应用库。\nRxJS 中解决异步事件管理的基本概念是：\n\nObservable：表示未来值或事件的可调用集合的想法，是多个值的惰性推送集合。\nObserver：是一个回调集合，使用它可以监听 Observable 传递的值。\nSubscription：表示一个 Observable 的执行，主要用于取消订阅。\nOperator：是纯粹的方法，可以处理和操作Observable传入的值，如集合功能的编程风格map，filter，concat，reduce等。\nSubject：相当于一个 EventEmitter，是将一个值或事件多播给多个 Observer 的方式。\nScheduler：是集中式的调度员控制并发性，使我们能够在计算例如发生在setTimeout或requestAnimationFrame中的事件。\n\nFunctional Reactive ProgrammingFunctional Reactive Programming是一种编程范式，涵盖了Functional Programming与Reactive Programming两种编程思想。\nFunctional Programming简单说Functional Programming核心思想就是做运算处理，并且使用function来思考问题，例如像以下的算术运算：\n(5 + 6) - 1 * 3\n我们可以写成：\nconst add = (a, b) =&gt; a + bconst mul = (a, b) =&gt; a * bconst sub = (a, b) =&gt; a - bsub(add(5, 6), mul(1, 3))\n我们把每个运算包成一个个不同的function，并用这些function组合出我们要的结果，这就是最简单的Functional Programming。\nReactive Programming\n很多人一谈到Reactive Programming 就会直接联想到是在讲RxJS，但实际上Reactive Programming 仍是一种编程范式，在不同的场景都有机会遇到，而非只存在于RxJS，尤雨溪(Vue 的作者)就曾在twitter 对此表达不满！\n\n\nReactive Programming 简单来说就是当变量或资源发生变动时，有变量或资源自动告诉我发生变动了。\n举个例子：当我们在使用vue 开发时，只要一有绑定的变量发生改变，相关的变量及页面也会跟着变动，而开发者不需要写这其中的任何一行代码。\nRx基本上就是上述两个观念的结合，这个部分相信读者在看完之后的章节，会有更深的感悟。\nObservable\n整个RxJS 的基础就是Observable，只要弄懂Observable 就算是学会一半的RxJS 了，剩下的就只是一些方法的练习跟熟悉，但到底什么是Observable呢？\n\n实际上，RxJS核心的Observable操作观念和FP的数组操作是极为相似的，只要学会以下几个基本的方法跟观念后，会让我们之后上手Observable简单很多！\n观察者模式(Observer Pattern)定义：定义了对象之间的依赖关系.可以通知所有依赖于它的对象(前端更多的是通知事件执行)。\n观察者模式其实很常用到，在许多API的设计上都用了观察者模式，最简单的例子就是DOM事件监听。\nfunction clickHandler(event) &#123;\tconsole.log(&#x27;user click!&#x27;);&#125;document.body.addEventListener(&#x27;click&#x27;, clickHandler)\n\n在上面的代码中，我们先声明了一个clickHandler函数，再用DOM来监听点击事件，每次使用者在body上点击一下就会执行一次clickHandler。这就是观察者模式，我们可以对某件事注册监听，并在事件发生时，自动执行我们注册的监听者。\nObserver的观念其实就是这么简单，下面我们来通过代码看看如何实作一个这样的Pattern。\n首先我们需要一个类，这个类new出来的实例可以被监听。\nclass Subject &#123;  private arrList: &#123; [fn: string]: Function &#125; = &#123;&#125;;  constructor() &#123;&#125;  register(name: string, fn: Function) &#123;    this.arrList[name] = fn;  &#125;  notify(name?: string, ...parameters: any[]) &#123;    if (name) &#123;      if (!this.arrList[name]) &#123;        throw new Error(`$&#123;name&#125;方法不存在`);      &#125;      this.arrList[name!]();    &#125; else &#123;      Object.values(this.arrList).forEach((fn: Function) =&gt; &#123;        fn.apply(fn, parameters);      &#125;);    &#125;  &#125;  remove(name: string) &#123;    delete this.arrList[name];  &#125;&#125;\n\n有了上面的代码后，我们就可以来建立实例并使用了。\nconst subject = new Subject();subject.register(&#x27;boil&#x27;, () =&gt; &#123;  console.log(&#x27;烧水&#x27;);&#125;);subject.register(&#x27;coding&#x27;, () =&gt; &#123;  console.log(&#x27;写代码&#x27;);&#125;);const share = () =&gt; &#123;  console.log(&#x27;分享&#x27;);  subject.notify(&#x27;coding&#x27;);&#125;;subject.remove(&#x27;boil&#x27;);share();\n\n当我们执行到这里时，会打印出：\n分享写代码\n完整代码 stackblitz\n我们可以在程序执行时去通知注册过的方法，在执行share方法时，coding也会执行，而这些方法可以被额外添加，也可以被移除。\n虽然我们的实例很简单，但它很好地说明了观察者模式如何在事件和监听者的互动中做到去耦合。\n迭代器模式(Iterator Pattern)迭代器模式分为内部迭代器与外部迭代器，它像一个指针，指向一个数据结构并产生一个数列，这个数列会有结构中的所有元素。\n内部迭代器内部迭代器的内部已经定义好了迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用。\nconst arr = [&#x27;Angular&#x27;, &#x27;React&#x27;, &#x27;Vue&#x27;];for (let i of arr) &#123;  console.log(i);&#125;\nstackblitz\n优点：调用方式简单，外部仅需一次调用。\n缺点：迭代规则预先设置，欠缺灵活性。无法实现复杂遍历需求（如: 同时迭代比对两个数组）。\n外部迭代器外部迭代器： 外部显示（手动）地控制迭代下一个数据项。\n借助ES6新增的iterator接口来实现外部迭代器。\nvar arr = [1, 2, 3];var iterator = arr[Symbol.iterator]();iterator.next();// &#123; value: 1, done: false &#125;iterator.next();// &#123; value: 2, done: false &#125;iterator.next();// &#123; value: 3, done: false &#125;iterator.next();// &#123; value: undefined, done: true &#125;\nstackblitz\n优点：灵活性更佳，适用面广，能应对更加复杂的迭代需求。\n缺点：需显示调用迭代进行（手动控制迭代过程），外部调用方式较复杂。\n思考这一段代码实现的是外部还是内部迭代器？\n\n欢迎在留言中一起讨论\n\nconst arr = [&#x27;Angular&#x27;, &#x27;React&#x27;, &#x27;Vue&#x27;];function* generatorEach() &#123;  const entries = arr.entries();  for (let [index, value] of arr.entries()) &#123;    yield console.log([index, value]);  &#125;&#125;const each = generatorEach();each.next();each.next();each.next();\nstackblitz\nObservable在了解观察者和迭代器模式之后，不知道大家有没有发现其实这两种设计模式有个共同的特性，就是他们都是渐进式的取得资料，差别只在于Observer是生产者推送资料(push)而Iterator是消费者要求资料(pull)。\n\nObservable其实就是这两种设计模式思想的结合，Observable具有生产者推送资料的特性，同时能像数列，拥有数列推送资料的方法。\n建立Observable(一)建立Observable的方法有非常多种，其中直接new出一个实例是最基本的方法。Observable类接受一个callback function，这个callback function会接受一个observer参数。\nconst observable = new Observable(subscriber =&gt; &#123;  subscriber.next(1);  subscriber.next(2);  subscriber.next(3);&#125;);\n这个callback function会决定observable将如何发送值。\n我们可以订阅这个observable，来接受他送出的值。\nconst subscription = observable.subscribe(  next =&gt; &#123;    console.log(&#x27;next&#x27;, next);  &#125;);\n当我们订阅之后他就会依序送出next 1 next 2 next 3\n此处有两个重点\n\nObservable只有当订阅(subscribe)之后才会开始推送值。\n虽然RxJS主要在处理非同步行为，但也同时可以处理同步行为，像上面的代码就是同步执行的。证明如下\n\nimport &#123; Observable &#125; from &#x27;rxjs&#x27;;const observable = new Observable(subscriber =&gt; &#123;  subscriber.next(1);  subscriber.next(2);  subscriber.next(3);&#125;);console.log(&#x27;just before subscribe&#x27;);const subscription = observable.subscribe(  next =&gt; &#123;    console.log(&#x27;next&#x27;, next);  &#125;,);console.log(&#x27;just after subscribe&#x27;);\nstackblitz\n当我们订阅之后他就会依序送出just before subscribe next 1 next 2 next 3 just after subscribe\nObserver(观察者)Observable可以被订阅，或者说可以被观察，而订阅Observable的对象又称为观察者(Observer)，观察者是一个具有三个方法的对象，每当Observable发送事件时，便会呼叫观察者相对应的方法。\n观察者的三个方法：\n\nnext: 每当Observable发送出新的值，next方法就会被执行。\ncomplete: 在Observable没有其他的值可以取得时，complete方法就会被执行，在complete执行之后，next方法就不会再起作用。\nerror: 每当Observable内部发生错误时，error方法就会被执行，类似与Promise的catch方法。\n\nimport &#123; of, map, Observable &#125; from &#x27;rxjs&#x27;;const source = new Observable(observer =&gt; &#123;  observer.next(&#x27;1&#x27;);  observer.next(&#x27;2&#x27;);  observer.complete();  observer.next(&#x27;not work&#x27;);&#125;);var observer = &#123;  next: function(value) &#123;    console.log(value);  &#125;,  error: function(error) &#123;    console.log(error);  &#125;,  complete: function() &#123;    console.log(&#x27;complete&#x27;);  &#125;&#125;;source.subscribe(observer);\nstackblitz\n上述代码会依次打印出1 2 complete\n从上面的代码我们可以看出在complete执行后，next方法就会自动失效，所以没有印出not work\n下面是发生错误的示例\nimport &#123; of, map, Observable &#125; from &#x27;rxjs&#x27;;const source = new Observable(observer =&gt; &#123;  observer.next(&#x27;1&#x27;);  observer.next(&#x27;2&#x27;);  throw &#x27;some exception&#x27;;  observer.complete();  observer.next(&#x27;not work&#x27;);&#125;);var observer = &#123;  next: function(value) &#123;    console.log(value);  &#125;,  error: function(error) &#123;    console.log(error);  &#125;,  complete: function() &#123;    console.log(&#x27;complete&#x27;);  &#125;&#125;;source.subscribe(observer);\nstackblitz\n这里会执行error的方法印出some exception。\n另外观察者可以使不完整的，他可以只具有一个next方法。\n我们也可以直接把next，error，complete三个方法依序传入observable.subscribe\nobservable.subscribe(    value =&gt; &#123; console.log(value); &#125;,    error =&gt; &#123; console.log(&#x27;Error: &#x27;, error); &#125;,    () =&gt; &#123; console.log(&#x27;complete&#x27;) &#125;)\n### **Marble diagrams(大理石图)**我们在传答事务时，文字其实是最糟糕的手段，虽然文字使我们平时沟通的基础，但常常千言万语都必不过一张清楚的图。如果我们能制定observable的图示，就能让我们更方便地理解observable的各种operators！我们将observable的图示称为Marble diagrams，在网络上RxJS有非常多的Marble diagrams，规则基本上大致相同。我们用```-```来表示一小段时间，这些```-```穿起来就表示一个observable\n\n```X```(大写X)则表示有错误发生。\n————————–X\n```|```则表示observable结束。\n————————–|\n在这个时间序列中，我们可能会送出值，如果是数字我们直接用阿拉伯数字，其他类型我们用相近的英文符号代替，这里我们用```interval```举例\n—–0—–1—–2—–3–…\n当observable是同步推送值的时候，例如```typescriptconst source = of(1,2,3,4);\n\n```(1234)|\n小括号代表着同步发生。\n另外Marble diagrams也可以表达operator的前后转换，例如\nconst source = interval(1000);const newest = source.pipe(map(x =&gt; x + 1));\n这时的Marble diagrams就会像这样\nsource: -----0-----1-----2-----3--...            map(x =&gt; x + 1)newest: -----1-----2-----3-----4--...\n最上面是原本的observable，中间是operator，下面则是新的observable。\n\nMarble diagrams相关资源：https://rxmarbles.com/\n\n以上就是Marble diagrams如何表示operator对observable的操作，下一章让我们来看几个简单的operator。\n建立Observable(二)\n通常我们并不会直接在项目中使用new Observable来建立Observable实例，而是会使用creation operator来建立Observable实例，下面我们会介绍几个常用到的operator。\n\nCreation Operatorcreation operator可以作为独立函数调用以创建新的 Observable。\n下面我们列出RxJS常用的creation operator\n\nof \nfromEvent\ninterval\ntimer\n\nof创建一个 observable，它将一个接一个地发出值。\n\n每个参数都想成为一个next通知。\n\nimport &#123; of &#125; from &#x27;rxjs&#x27;;of(10, 20, 30).subscribe(  next =&gt; console.log(&#x27;next:&#x27;, next),  err =&gt; console.log(&#x27;error:&#x27;, err),  () =&gt; console.log(&#x27;the end&#x27;),);// Outputs// next: 10// next: 20// next: 30// the end\n\nMarble diagrams像是这样。\n(102030)|\n\nfromEvent创建一个 Observable，它发出来自给定事件目标的特定类型的事件，行为类似与原生JS的addEventListener方法。\nimport &#123; fromEvent &#125; from &#x27;rxjs&#x27;;const clicks = fromEvent(document, &#x27;click&#x27;);clicks.subscribe(x =&gt; console.log(x));\n这里我们给Document对象注册了点击事件，在点击页面后会打印出MouseEvent对象。\nMarble diagrams像是这样。\n----------ev-----ev\n\n思考这里如果没有订阅(subscribe)，事件会被绑定到Document对象上吗？\ninterval创建一个Observable，每个时间间隔发出一个序列号，行为类似与原生JS的setInterval。\nimport &#123; interval &#125; from &#x27;rxjs&#x27;;import &#123; take &#125; from &#x27;rxjs/operators&#x27;;const numbers = interval(1000);numbers.subscribe(x =&gt; console.log(&#x27;Next: &#x27;, x));\n\n这里会从0开始每隔一秒输出一次，每次递增1。\nMarble diagrams像是这样。\n-----0-----1-----2--..\n\ntimer当timer有两个参数时，第一个参数代表要发出第一个值的等待时间(ms)，第二个参数代表第一次之后发送值的间隔时间。\nimport &#123; timer, interval &#125; from &#x27;rxjs&#x27;;timer(1000, 3000).subscribe(n =&gt; console.log(&#x27;timer&#x27;, n));\n上述代码会在一秒后输出0，之后每隔三秒输出一次，每次递增1。\nMarble diagrams像是这样。\n-----0---------------1---------------2-----...\n\nSubscription不知道大家有没有发现，我们在上一章介绍操作符的时候，有很多无穷的observable，例如interval与timer，但是有的时候我们可能会在某些行为后不再需要这些资源，要做到这件事最简单的方式就是unsubscribe。\n其实在订阅observable之后，会回传一个subscription对象，这个方法具有释放资源的unsubscribe方法。\nimport &#123; interval &#125; from &#x27;rxjs&#x27;;const observable = interval(1000);const subscription = observable.subscribe(x =&gt; console.log(x));setTimeout(() =&gt; &#123;  subscription.unsubscribe();&#125;, 5000);\nstackblitz\n这里我们用了setTimeout在5秒后执行了subscription.unsubscribe()来停止订阅并且释放资源。\nOperator(操作符)\n尽管 Observable 是基础，但RxJS 最有用的却是它的操作符。操作符是允许以声明方式轻松组合复杂异步代码的基本部分。\n\n什么是Operator？Operator就是函数。目前按照大类来分有两种运算符。\n\nCreation Operator：是可以作为独立函数调用以创建新的Observable的一种操作符，也是我们在前些章节介绍过的。\nPipeable Operator：是另一种可以使用语法通过管道(pipe)传输到Observables的操作符。在调用时，它们不会更改现有的Observable实例，它们会返回一个新的Observable，其订阅逻辑基于第一个Observable。\n\n\nPipeable Operator 是一个将 Observable 作为其输入并返回另一个 Observable 的函数。这是一个纯粹的操作：之前的 Observable 保持不变。\n\nPipeable Operator本质上是一个纯函数，它将一个Observable作为输入并生成另一个Observable作为输出。订阅输出Observable也会订阅输入Observable。\n这也就是为什么说RxJS是Functional Programming的依据之一。\n由于我们在前些章节介绍过creation operator，在这章我们主要介绍Pipeable operator。\n让我们从两个实例开始认识管道类操作符。\n防抖用到的操作符\n\ndebounceTime: 仅在经过特定时间跨度且没有其他源发射后才从源 Observable 发出通知。\ndiagrams像是这样   ```   source: -----1-----2-3-45--------3--...            debounceTime(100)   newest: -----1----------5--------3--...   ```   2. map: 将给定的函数应用于源Observable发出的每个值，并将结果值作为 Observable 发出，效果用法等同于ES6的数组的map方法。   ```map```的Marble diagrams像是这样\nsource: —–0—–1—–2—–3–…        map(x &#x3D;&gt; x + 1)newest: —–1—–2—–3—–4–…\n   ##### 第一步，我们获取到所需的dom元素。HTML:```html&lt;input type=&#x27;text&#x27; id=&#x27;input&#x27;&gt;\n\nTypeScript:\nconst input = document.querySelector(&#x27;#input&#x27;);\n\n第二步，使用之前说过的fromEvent为input元素绑定input事件。import &#123; of, fromEvent &#125; from &#x27;rxjs&#x27;;import &#123; debounceTime, distinctUntilChanged, map &#125; from &#x27;rxjs/operators&#x27;;const input = document.querySelector(&#x27;#input&#x27;);fromEvent(input, &#x27;input&#x27;)  .subscribe(console.log);\n效果图\n这时我们输入值的话可以看到每一次输入都会打印一次InputEvent，如果想要做到在每次输入之后等待100ms再打印值也很简单，只需要加入debounceTime(100)。\n第三步，这里我们使用map获取输入的值，然后使用debounceTime操作符完成基础的防抖功能。import &#123; of, fromEvent &#125; from &#x27;rxjs&#x27;;import &#123; debounceTime, distinctUntilChanged, map &#125; from &#x27;rxjs/operators&#x27;;const input = document.querySelector(&#x27;#input&#x27;);fromEvent(input, &#x27;input&#x27;)  .pipe(    debounceTime(100),    map((x: InputEvent) =&gt; (x.target as HTMLInputElement).value)  )  .subscribe(console.log);\n\n效果图\n此时我们可以看到在已经具有防抖的效果了。\n完整代码 stackblitz\n拖拽用到的操作符\n\nswitchMap: 高阶操作符之一，可以根据传入的Observable重新生成一个新的Observable并且返回。\n 例\n const source = fromEvent(document.body, &#x27;click&#x27;);const example = source.pipe(switchMap(e =&gt; interval(1000)));example.subscribe(&#123;  next: value =&gt; &#123;    console.log(value);  &#125;,  error: err =&gt; &#123;    console.log(&#x27;Error: &#x27; + err);  &#125;,  complete: () =&gt; &#123;    console.log(&#x27;complete&#x27;);  &#125;&#125;);\n 在我们点击body的时候会将点击事件的事件对象装换为interval并且使用switchMap将interval转换为一阶observable(就是被订阅过的)。\n 此时的Marble Diagram像是这样。\n source : -----------ev-------------------...      switchMap(c =&gt; interval(1000))example: ---------------0--1--2----------...\ntakeUntil: 在实际场景中takeUntil经常用到，他可以在某件事发生时让一个observable直接触发complete方法。\n 例\n const example = interval(1000).pipe(takeUntil(click));const click = fromEvent(document.body, &#x27;click&#x27;);example.subscribe(&#123;    next: (value) =&gt; &#123; console.log(value); &#125;,    error: (err) =&gt; &#123; console.log(&#x27;Error: &#x27; + err); &#125;,    complete: () =&gt; &#123; console.log(&#x27;complete&#x27;); &#125;&#125;);\n 这里我们为body元素注册了点击事件，随后我们创建了一个无限发送值的observable - interval并且为其绑定了takeUntil为点击事件。这样在我们点击body的时候就会调用interval的complete方法来取消interval。\n 此时的Marble Diagram像是这样。\n source : -----0-----1-----2------3--click  : ----------------------c----takeUntil(click)example: -----0-----1-----2----|\nwithLatestFrom: 接受两个参数，第一个为另一个observable对象，第二个是一个callback function，可以将两个observable合并，并且在主要的observable送出新的值时才会执行callback。\n 例\n const clicks = fromEvent(document, &#x27;click&#x27;);const timer = interval(1000);const result = clicks.pipe(  withLatestFrom(timer, (event, time) =&gt; &#123;    return &#123; event, time &#125;;  &#125;));result.subscribe(x =&gt; console.log(x));\n 这里我们为document对象注册了点击事件并且创建了interval，随后我们使用withLatestFrom操作符将两个observable合并，这样在主observable(click事件)发生的时候会执行withLatestFrom的回调函数。\n 此时的Marble Diagram像是这样。\n timer : -----0------1-------2--------3--|clicks  : -------ev---------------ev---|               withLatestFromexample: --------ev0--------------ev2--|\n\n需求分析\n首先页面上有一個元素(main)。\n当鼠标在元素(#main)上按下左鍵(mousedown)时，开始监听鼠标移动(mousemove)事件，获取位置。\n当鼠标左键放开(mouseup)时，结束监听鼠标移动事件。\n当鼠标移动(mousemove)被监听时，跟着修改元件的样式属性。\n\n第一步，取得会用到的dom元素。HTML\n&lt;style&gt;  .main &#123;    width: 100px;    height: 100px;    text-align: center;    line-height: 100px;    background-color: deepskyblue;  &#125;&lt;/style&gt;&lt;div class=&quot;main&quot; id=&quot;main&quot;&gt;  main&lt;/div&gt;\nTypeScript\nconst main: HTMLElement = document.querySelector(&#x27;.main&#x27;);\n\n第二步，建立会用到的observableconst mouseUp = fromEvent(document, &#x27;mouseup&#x27;);const mouseDown = fromEvent(main, &#x27;mousedown&#x27;);const mouseMove = fromEvent(document, &#x27;mousemove&#x27;);\n\n第三步，撰写代码逻辑首先我们需要当鼠标在元素(#main)上按下左鍵(mousedown)时，开始监听鼠标移动(mousemove)事件，并且在鼠标抬起(mouseup)的时候取消对鼠标移动事件的监听。\nmouseDown  .pipe(    switchMap(_ =&gt; mouseMove.pipe(takeUntil(mouseUp))),  )  .subscribe(x =&gt; &#123;    console.log(x);  &#125;);\n\n此时我们已经做到了上述的需求了，接下来我们只需要获取鼠标点下时候的位置并且计算就可以得到鼠标的位置信息。\nmouseDown  .pipe(    switchMap(_ =&gt; mouseMove.pipe(takeUntil(mouseUp))),    // map(_ =&gt; mouseMove.pipe(takeUntil(mouseUp))),    // concatAll(),    withLatestFrom(mouseDown, (move: MouseEvent, down: MouseEvent) =&gt; &#123;      return &#123;        x: move.pageX - down.offsetX,        y: move.pageY - down.offsetY      &#125;;    &#125;)  )  .subscribe(x =&gt; &#123;    console.log(x);  &#125;);\n这里我们使用withLatestFrom操作符来获取鼠标按下时的事件对象，并且计算得到鼠标的坐标点(x , y)，并将之传递给subscribe方法。\n最后我们改变div的样式，完成拖拽效果。\nsubscribe(x =&gt; &#123;    main.style.transform = `translate($&#123;x.x&#125;px, $&#123;x.y&#125;px)`;  &#125;);\n\n效果图\n完整代码 stackblitz\nskipimport &#123; of, map, interval &#125; from &#x27;rxjs&#x27;;import &#123; skip &#125; from &#x27;rxjs/operators&#x27;;const source = interval(1000).pipe(skip(2));source.subscribe(console.log);\nstackblitz\n原本从0开始的打印会变为从3开始，但是记得原本需要等待的时间仍然存在。\n此时的Marble Diagram是这样的。\n-----0-----1-----2--...     skip(2)-----------------2--...\n\ntakeLast```typescriptimport &#123; of, map &#125; from &#x27;rxjs&#x27;;import &#123; takeLast &#125; from &#x27;rxjs/operators&#x27;;const source = of(1, 2, 3, 4, 5).pipe(takeLast(1));source.subscribe(console.log);\nstackblitz\n这里我们使用of一共发送了5个元素随后使用takeLast(1)获取最后一个发送的值，这里有一个重点，就是takeLast必须等到整个observable完成(complete)，才可以知道最后的元素有哪一些，并且同步送出。\n此时的Marble Diagram是这样的。\n(12345)|takeLast(1)-----5|\n\nlastlast等效于takeLast(1),是takeLast(1)的简化写法。\nconcat```typescriptimport &#123; interval, of &#125; from &#x27;rxjs&#x27;;import &#123; concat &#125; from &#x27;rxjs/operators&#x27;;const source = interval(1000).pipe(take(3));const source2 = of(3);const source3 = of(4, 5, 6);const example = source.pipe(concat(source2, source3));example.subscribe(&#123;  next: value =&gt; &#123;    console.log(value);  &#125;,  error: err =&gt; &#123;    console.log(&#x27;Error: &#x27; + err);  &#125;,  complete: () =&gt; &#123;    console.log(&#x27;complete&#x27;);  &#125;&#125;);\nstackblitz\n此时的Marble Diagram\nsource : —-0—-1—-2|source2: (3)|source3: (456)|            concat()example: —-0—-1—-2(3456)|\n### **merge**```merge```和```concat```一样都是用来合并observable，但是他们的行为却完全不同！让我们直接来看例子吧。```typescriptimport &#123; of, map, interval &#125; from &#x27;rxjs&#x27;;import &#123; merge &#125; from &#x27;rxjs/operators&#x27;;const source = interval(500);const source2 = interval(300);const example = source.pipe(merge(source2));example.subscribe(&#123;   next: value =&gt; &#123;      console.log(value);   &#125;,   error: err =&gt; &#123;      console.log(&#x27;Error: &#x27; + err);   &#125;,   complete: () =&gt; &#123;      console.log(&#x27;complete&#x27;);   &#125;&#125;);\nstackblitz\n从下面的大理石图可以看到merge后的example在时间的顺序上同时在跑 source 与 source2，当两件事同时发生时，会同步的送出值，当两个observable全部结束才会真的结束。\nsource : ----0----1----2|source2: --0--1--2--3--4--5|         merge()example: --0-01--21-3--(24)--5|\nSubject\n终于进入了RxJS的第二个重点Subject，不知道读者们有没有发现？我们在这篇文章之前的范例，每个observable都只订阅了一次，而实际上observable是可以多次订阅的。\n\nMultiple subscriptionsconst observable = interval(1000);observable.subscribe(x =&gt; &#123;  console.log(&#x27;A:&#x27;, x);&#125;);observable.subscribe(x =&gt; &#123;  console.log(&#x27;B:&#x27;, x);&#125;);\n输出\n&quot;A next: 0&quot;&quot;B next: 0&quot;&quot;A next: 1&quot;&quot;B next: 1&quot;&quot;A next: 2&quot;...&quot;B next: 2&quot;...\n\n上面的这段代码，分别用observerA和observerB订阅了source，从log我们可以看出observerA和observerB都各自收到了元素，但请记住两个observer其实是分开执行的，也就是说他们是完全独立的，我们将observerB延迟订阅来证明看看。\nconst observable = interval(1000);observable.subscribe(x =&gt; &#123;  console.log(&#x27;A:&#x27;, x);&#125;);setTimeout(() =&gt; &#123;  observable.subscribe(x =&gt; &#123;    console.log(&#x27;B:&#x27;, x);  &#125;);&#125;, 1000);\n\n这里我们延迟一秒再用observerB 订阅，可以从log 中看出1 秒后observerA 已经印到了1，这时observerB 开始印却是从0 开始，而不是接着observerA 的进度，代表这两次的订阅是完全分开来执行的，或者说是每次的订阅都建立了一个新的执行。\n这样的行为在大部分的情境下适用，但有些案例下我们会希望第二次订阅source 不会从头开始接收元素，而是从第一次订阅到当前处理的元素开始发送，我们把这种处理方式称为多播(multicast)。那我们该怎样实现多播呢？\n什么是Subject？RxJS Subject 是一种特殊类型的 Observable，它允许将值多播到许多观察者。虽然普通的 Observable 是单播的(每个订阅的 Observer 拥有一个独立的 Observable 执行)，但Subject是多播的。\n每个 Subject 都是一个 Observable。给定一个Subject，你可以订阅(subscribe)它，提供一个观察者，它将开始正常接收值。从观察者(Observer)的角度来看，它无法判断 Observable 的执行是来自一个普通的单播 Observable 还是一个 Subject。\n每个Subject都是Observer。它拥有Observer的三个方法next(v)，error(e)和complete()。要向 Subject 提供一个新值，只需调用next(theValue)，它将被多播到注册的 Observers 以侦听 Subject。\n在下面的例子中，我们有两个Observer附加到一个Subject，并且在一秒后才注册observerB：\nimport &#123; Subject &#125; from &#x27;rxjs&#x27;;const subject = new Subject&lt;number&gt;();subject.subscribe(&#123;  next: (v) =&gt; console.log(`observerA: $&#123;v&#125;`)&#125;);setTimeout(() =&gt; &#123;  subject.next(2);  subject.subscribe(&#123;    next: (v) =&gt; console.log(`observerB: $&#123;v&#125;`)  &#125;);&#125;, 1000);subject.next(1);\nstackblitz\n输出\nobserverA: 1observerA: 2observerB: 2\n通过上述方法，我们通过Subject将单播Observable执行转换为多播。\n还有的几个特例Subject类型：BehaviorSubject，ReplaySubject，和AsyncSubject。\nBehaviorSubjectBehaviorSubject 跟Subject 最大的不同就是BehaviorSubject 是用来呈现当前的值，而不是单纯的发送事件。BehaviorSubject 会记住最新一次发送的元素，并把该元素当作目前的值，在使用上BehaviorSubject 建构式需要传入一个参数来代表起始的状态，范例如下\nimport &#123; BehaviorSubject &#125; from &#x27;rxjs&#x27;;var subject = new BehaviorSubject(0);var observerA = &#123;  next: value =&gt; console.log(&#x27;A next: &#x27; + value),  error: error =&gt; console.log(&#x27;A error: &#x27; + error),  complete: () =&gt; console.log(&#x27;A complete!&#x27;)&#125;;var observerB = &#123;  next: value =&gt; console.log(&#x27;B next: &#x27; + value),  error: error =&gt; console.log(&#x27;B error: &#x27; + error),  complete: () =&gt; console.log(&#x27;B complete!&#x27;)&#125;;subject.subscribe(observerA);// &quot;A next: 0&quot;subject.next(1);// &quot;A next: 1&quot;subject.next(2);// &quot;A next: 2&quot;subject.next(3);// &quot;A next: 3&quot;setTimeout(() =&gt; &#123;  subject.subscribe(observerB);  // &quot;B next: 3&quot;&#125;, 3000);\nstackblitz\n从上面这个范例可以看得出来BehaviorSubject 在建立时就需要给定一个状态，并在之后任何一次订阅，就会先送出最新的状态。其实这种行为就是一种状态的表达而非单纯的事件，就像是年龄跟生日一样，年龄是一种状态而生日就是事件；所以当我们想要用一个stream 来表达年龄时，就应该用BehaviorSubject。\nReplaySubject在某些时候我们会希望Subject 代表事件，但又能在新订阅时重新发送最后的几个元素，这时我们就可以用ReplaySubject，范例如下\nimport &#123; ReplaySubject &#125; from &#x27;rxjs&#x27;;var subject = new ReplaySubject(2);var observerA = &#123;  next: value =&gt; console.log(&#x27;A next: &#x27; + value),  error: error =&gt; console.log(&#x27;A error: &#x27; + error),  complete: () =&gt; console.log(&#x27;A complete!&#x27;)&#125;;var observerB = &#123;  next: value =&gt; console.log(&#x27;B next: &#x27; + value),  error: error =&gt; console.log(&#x27;B error: &#x27; + error),  complete: () =&gt; console.log(&#x27;B complete!&#x27;)&#125;;subject.subscribe(observerA);subject.next(1);// &quot;A next: 1&quot;subject.next(2);// &quot;A next: 2&quot;subject.next(3);// &quot;A next: 3&quot;setTimeout(() =&gt; &#123;  subject.subscribe(observerB);  // &quot;B next: 2&quot;  // &quot;B next: 3&quot;&#125;, 3000);\nstackblitz\nAsyncSubjectAsyncSubject 会在subject 结束后才送出最后一个值，其实这个行为跟Promise 很像，都是等到事情结束后送出一个值，但实践中我们非常非常少用到AsyncSubject，绝大部分的时候都是使用BehaviorSubject 跟ReplaySubject 或Subject。\nimport &#123; AsyncSubject &#125; from &#x27;rxjs&#x27;;var subject = new AsyncSubject();var observerA = &#123;  next: value =&gt; console.log(&#x27;A next: &#x27; + value),  error: error =&gt; console.log(&#x27;A error: &#x27; + error),  complete: () =&gt; console.log(&#x27;A complete!&#x27;)&#125;;var observerB = &#123;  next: value =&gt; console.log(&#x27;B next: &#x27; + value),  error: error =&gt; console.log(&#x27;B error: &#x27; + error),  complete: () =&gt; console.log(&#x27;B complete!&#x27;)&#125;;subject.subscribe(observerA);subject.next(1);subject.next(2);subject.next(3);subject.complete();// &quot;A next: 3&quot;// &quot;A complete!&quot;setTimeout(() =&gt; &#123;  subject.subscribe(observerB);  // &quot;B next: 3&quot;  // &quot;B complete!&quot;&#125;, 3000);\nstackblitz\n冷与热的Observable在上一章我们介绍了各种Subject，不晓得各位读者还记不记得一开始讲到Subject时，是希望能够让Observable在有新订阅的时候，可以共用前一个订阅的执行而不是从头开始。\n冷的Observable\n还记得下面的例子吗？\n\nimport &#123; AsyncSubject, interval &#125; from &#x27;rxjs&#x27;;var source = interval(1000);var observerA = &#123;  next: value =&gt; console.log(&#x27;A next: &#x27; + value),  error: error =&gt; console.log(&#x27;A error: &#x27; + error),  complete: () =&gt; console.log(&#x27;A complete!&#x27;)&#125;;var observerB = &#123;  next: value =&gt; console.log(&#x27;B next: &#x27; + value),  error: error =&gt; console.log(&#x27;B error: &#x27; + error),  complete: () =&gt; console.log(&#x27;B complete!&#x27;)&#125;;source.subscribe(observerA);setTimeout(() =&gt; &#123;  source.subscribe(observerB);&#125;, 1000);\n上面这段代码我们分别用两个Observer去订阅同一个Observable，在observerA已经输出了A next: 0与A next: 1的时候observerB会输出B next: 0，这就是单播也叫做冷的Observable，这两个序列完全是按照各自的节奏走的，不同步。每个流在订阅的时候都会从0开始。\n那么我们如何让使其变为多播的Observable呢？\n热的Observable热的Observable：多播。所有的观察者，无论进来的早还是晚，看到的是同样内容的同样进度，订阅的时候得到的都是最新时刻发送的值。\n在RxJS中想让Observable多播很简单，只需要加入multicast操作符(Operator)。\nmulticastmulticast可以用来挂载subject并回传一个可连接(connectable)的observable，如下\nimport &#123; Subject, AsyncSubject, interval &#125; from &#x27;rxjs&#x27;;import &#123; multicast &#125; from &#x27;rxjs/operators&#x27;;var source = interval(1000).pipe(multicast(new Subject()));var observerA = &#123;  next: value =&gt; console.log(&#x27;A next: &#x27; + value),  error: error =&gt; console.log(&#x27;A error: &#x27; + error),  complete: () =&gt; console.log(&#x27;A complete!&#x27;)&#125;;var observerB = &#123;  next: value =&gt; console.log(&#x27;B next: &#x27; + value),  error: error =&gt; console.log(&#x27;B error: &#x27; + error),  complete: () =&gt; console.log(&#x27;B complete!&#x27;)&#125;;source.connect();source.subscribe(observerA);setTimeout(() =&gt; &#123;  source.subscribe(observerB);&#125;, 1000);\n\n上面这段代码会在observerA输出A next: 0与A next: 1的时候observerB会输出B next: 1，有没有发现不一样的地方，在这里两个observer才是真正同步的执行了。\n上面这段代码我们通过multicast来挂载一个subject之后这个observable(上面代码中的source)的订阅其实都是订阅到subject上面。\n并且必须要等到执行connect()之后才会整的用subject订阅source，并开始送出元素，如果没有执行connect()，observable是不会真正执行的。\n另外值得注意的是如果这里需要取消订阅的话，需要将connect()回传的subscription取消订阅才会真正停止observable的执行。\nconst subscription = source.connect();subscription.unsubscribe();\n\n虽然用了multicast感觉会让我们处理的对象少一些，但是必须搭配connect一起使用还是会使程序有一些复杂，通常我们会希望有observer订阅的时候，就立即执行并发送元素，而不要再多去执行一个方法(connect)，这个时候我们就可以用到refCount。\nrefCountrefCount 必须搭配multicast 一起使用，他可以建立一个只要有订阅就会自动connect 的observable，范例如下\nimport &#123; Subject, AsyncSubject, interval &#125; from &#x27;rxjs&#x27;;import &#123; multicast, refCount &#125; from &#x27;rxjs/operators&#x27;;var source = interval(1000).pipe(  multicast(new Subject()),  refCount());var observerA = &#123;  next: value =&gt; console.log(&#x27;A next: &#x27; + value),  error: error =&gt; console.log(&#x27;A error: &#x27; + error),  complete: () =&gt; console.log(&#x27;A complete!&#x27;)&#125;;var observerB = &#123;  next: value =&gt; console.log(&#x27;B next: &#x27; + value),  error: error =&gt; console.log(&#x27;B error: &#x27; + error),  complete: () =&gt; console.log(&#x27;B complete!&#x27;)&#125;;source.subscribe(observerA);setTimeout(() =&gt; &#123;  source.subscribe(observerB);&#125;, 1000);\n\n上面这段程式码，当source 一被observerA 订阅时(订阅数从0 变成1)，就会立即执行并发送元素，我们就不需要再额外执行connect。\n同样的在退订时只要订阅数变成0 就会自动停止发送\npublish其实multicast(new Subject()) 很常用到，我们有一个简化的写法那就是publish，下面这两段代码完全是等价的。\nconst source1 = interval(1000)  .pipe(    publish(),    refCount(),  )const source2 = interval(1000)  .pipe(    multicast(new Subject()),    refCount(),  )\n\n加上Subject的三种变形：\nconst source1 = interval(1000)  .pipe(     publishReplay(1),     refCount(),  )\nconst source1 = interval(1000)  .pipe(    publishBehavior(0) ,    refCount(),  )\nconst source1 = interval(1000)  .pipe(     publishLast(),     refCount(),  )\n\nshare另外publish + refCount可以继续简写为share\nconst source1 = interval(1000)  .pipe(    share()  )\n\n总结RxJS是一个强大的Reactive编程库，提供了强大的数据流组合与分支控制能力，但是其学习门槛一直很高，本文介绍了RxJS的一些概念与实例，梳理了观察者模式和迭代器模式与RxJS之间的关系，把RxJS的一个核心两个重点(Observable + Observer + Subject)以及一些operators也有写到，期望可以让各位读者对RxJS有一个大致的了解，简化学习的过程。\n感谢您的阅读，我是数字办的鲁举佩，期待与您共同成长！！！\n"},{"title":"解析LeetCode开源的一道TypeScript类型编程问题","url":"//2023/06/28/%E8%A7%A3%E6%9E%90LeetCode%E5%BC%80%E6%BA%90%E7%9A%84%E4%B8%80%E9%81%93TypeScript%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/","content":"前言前一阵子偶然间看到了有LeetCode开源的一道TS题，好奇之下我点进入看了一下，没想到仔细一看，居然一行代码都看不懂，让我备受打击，于是我挑灯夜战，连夜学习Ts类型编程，终于在努力了半把个月之后于今日将此题解出，写此文章记录的同时也分享给大家。\n顺手贴入原题地址：编写复杂TS类型\n问题定义假设有一个叫 EffectModule 的类\nclass EffectModule &#123;&#125;\n\n这个对象上的方法只可能有两种类型签名:\ninterface Action&lt;T&gt; &#123;  payload?: T  type: string&#125;asyncMethod&lt;T, U&gt;(input: Promise&lt;T&gt;): Promise&lt;Action&lt;U&gt;&gt;syncMethod&lt;T, U&gt;(action: Action&lt;T&gt;): Action&lt;U&gt;\n\n这个对象上还可能有一些任意的非函数属性：\ninterface Action&lt;T&gt; &#123;  payload?: T;  type: string;&#125;class EffectModule &#123;  count = 1;  message = &quot;hello!&quot;;  delay(input: Promise&lt;number&gt;) &#123;    return input.then(i =&gt; (&#123;      payload: `hello $&#123;i&#125;!`,      type: &#x27;delay&#x27;    &#125;));  &#125;  setMessage(action: Action&lt;Date&gt;) &#123;    return &#123;      payload: action.payload!.getMilliseconds(),      type: &quot;set-message&quot;    &#125;;  &#125;&#125;\n\n现在有一个叫 connect 的函数，它接受 EffectModule 实例，将它变成另一个对象，这个对象上只有EffectModule 的同名方法，但是方法的类型签名被改变了:\nasyncMethod&lt;T, U&gt;(input: Promise&lt;T&gt;): Promise&lt;Action&lt;U&gt;&gt;  变成了asyncMethod&lt;T, U&gt;(input: T): Action&lt;U&gt; syncMethod&lt;T, U&gt;(action: Action&lt;T&gt;): Action&lt;U&gt;  变成了syncMethod&lt;T, U&gt;(action: T): Action&lt;U&gt;\n\n例子:\nEffectModule 定义如下:\ninterface Action&lt;T&gt; &#123;  payload?: T;  type: string;&#125;class EffectModule &#123;  count = 1;  message = &quot;hello!&quot;;  delay(input: Promise&lt;number&gt;) &#123;    return input.then(i =&gt; (&#123;      payload: `hello $&#123;i&#125;!`,      type: &#x27;delay&#x27;    &#125;));  &#125;  setMessage(action: Action&lt;Date&gt;) &#123;    return &#123;      payload: action.payload!.getMilliseconds(),      type: &quot;set-message&quot;    &#125;;  &#125;&#125;connect 之后:type Connected = &#123;  delay(input: number): Action&lt;string&gt;  setMessage(action: Date): Action&lt;number&gt;&#125;const effectModule = new EffectModule()const connected: Connected = connect(effectModule)\n\n要求在 题目链接 里面的 index.ts 文件中，有一个 type Connect = (module: EffectModule) =&gt; any，将 any 替换成题目的解答，让编译能够顺利通过，并且 index.ts 中 connected 的类型与:\ntype Connected = &#123;  delay(input: number): Action&lt;string&gt;;  setMessage(action: Date): Action&lt;number&gt;;&#125;\n\n完全匹配。\n题目链接里的index.ts文件。\nimport &#123; expect &#125; from &quot;chai&quot;;interface Action&lt;T&gt; &#123;  payload?: T;  type: string;&#125;class EffectModule &#123;  count = 1;  message = &quot;hello!&quot;;  delay(input: Promise&lt;number&gt;) &#123;    return input.then(i =&gt; (&#123;      payload: `hello $&#123;i&#125;!`,      type: &#x27;delay&#x27;    &#125;));  &#125;  setMessage(action: Action&lt;Date&gt;) &#123;    return &#123;      payload: action.payload!.getMilliseconds(),      type: &quot;set-message&quot;    &#125;;  &#125;&#125;// 修改 Connect 的类型，让 connected 的类型变成预期的类型type Connect = (module: EffectModule) =&gt; any;const connect: Connect = m =&gt; (&#123;  delay: (input: number) =&gt; (&#123;    type: &#x27;delay&#x27;,    payload: `hello 2`  &#125;),  setMessage: (input: Date) =&gt; (&#123;    type: &quot;set-message&quot;,    payload: input.getMilliseconds()  &#125;)&#125;);type Connected = &#123;  delay(input: number): Action&lt;string&gt;;  setMessage(action: Date): Action&lt;number&gt;;&#125;;export const connected: Connected = connect(new EffectModule());\n\n题目解析分析题目可知，我们需要做的就是将28行的any替换为我们自己解析出来的符合Connected的类型。\nany =&gt; &#123;  delay(input: number): Action&lt;string&gt;  setMessage(action: Date): Action&lt;number&gt;&#125;\n\n\n当然我们不能把类型直接粘贴过去，还是要我们自己根据类型推断得出。\n\n思路与解题过程\n由于我们只想要获取类中的两个方法类型，所以我们需要去除EffectModule类中的count与message（或者更多的非Function）字段。\n\ntype PickMethodNames&lt;T&gt; = &#123;[P in keyof T]: T[P] extends Function ? P : never&#125;[keyof T];\n\n这里就是对传递的泛型T进行遍历，如果值是继承自Function，则将该值设置为P，否则就是never，然后根据T的键获取值。\n传入EffectModule之后类型为delay | setMessage\n\n我们需要将EffectModule里方法的”旧“类型变为“新”类型。\n\ntype asyncMethod&lt;T, U&gt; = (input: Promise&lt;T&gt;) =&gt; Promise&lt;Action&lt;U&gt;&gt;;type syncMethod&lt;T, U&gt; = (action: Action&lt;T&gt;) =&gt; Action&lt;U&gt;;type connectAsyncMethod&lt;T, U&gt; = (input: T) =&gt; Action&lt;U&gt;;type connectSyncMethod&lt;T, U&gt; = (action: T) =&gt; Action&lt;U&gt;;\n\n这里为了代码雅观提前声明好了四个类型，前两个asyncMethod与syncMethod我们称之为旧类型，connectAsyncMethod与connectSyncMethod两个类型为我们最终需要的类型，我们称之为新类型。\n最终题解：\ntype Solution&lt;T, U extends keyof T = PickMethodNames&lt;T&gt;&gt; = &#123; [P in U]: T[P] extends   asyncMethod&lt;infer O, infer B&gt; ? connectAsyncMethod&lt;O, B&gt;   : T[P] extends syncMethod&lt;infer I, infer W&gt; ? connectSyncMethod&lt;I, W&gt;   : never&#125;;type Connect = (module: EffectModule) =&gt; Solution&lt;EffectModule&gt;;\n\n在这里我们使用了infer关键字来推断类型。\n首先声明了两个泛型T和U并给U赋初始值PickMethodNames，然后我们去遍历U（其实就是遍历&quot;delay&quot; | &quot;setMessage&quot;），接着根据类型判断是否继承自”旧“类型，这里用到了工具方法infer来推断并定义“旧“类型两个泛型的类型，并将其赋值给我们的”新“方法，这样就完成了从旧到新的转换，之后的逻辑同理可得，这里就不多赘述了。\n得到的类型：\n\n\n注：这里为了得到最终类型将本来放置泛型的地方改为EffectModule（Vsode背锅）\n\n全部代码如下：interface Action&lt;T&gt; &#123;  payload?: T;  type: string;&#125;class EffectModule &#123;  count = 1;  message = &quot;hello!&quot;;  delay(input: Promise&lt;number&gt;) &#123;    return input.then(i =&gt; (&#123;      payload: `hello $&#123;i&#125;!`,      type: &#x27;delay&#x27;    &#125;));  &#125;  setMessage(action: Action&lt;Date&gt;) &#123;    return &#123;      payload: action.payload!.getMilliseconds(),      type: &quot;set-message&quot;    &#125;;  &#125;&#125;type asyncMethod&lt;T, U&gt; = (input: Promise&lt;T&gt;) =&gt; Promise&lt;Action&lt;U&gt;&gt;;type syncMethod&lt;T, U&gt; = (action: Action&lt;T&gt;) =&gt; Action&lt;U&gt;;type connectAsyncMethod&lt;T, U&gt; = (input: T) =&gt; Action&lt;U&gt;;type connectSyncMethod&lt;T, U&gt; = (action: T) =&gt; Action&lt;U&gt;;// -----------------------题解-------------------------------type PickMethodNames&lt;T&gt; = &#123;[P in keyof T]: T[P] extends Function ? P : never&#125;[keyof T];type Solution&lt;T, U extends keyof T = PickMethodNames&lt;T&gt;&gt; = &#123; [P in U]: T[P] extends asyncMethod&lt;infer O, infer B&gt; ? connectAsyncMethod&lt;O, B&gt; : T[P] extends syncMethod&lt;infer I, infer W&gt; ? connectSyncMethod&lt;I, W&gt; : never&#125;;type Connect = (module: EffectModule) =&gt; Solution&lt;EffectModule&gt;;// -----------------------题解-------------------------------const connect: Connect = m =&gt; (&#123;  delay: (input: number) =&gt; (&#123;    type: &#x27;delay&#x27;,    payload: `hello 2`  &#125;),  setMessage: (input: Date) =&gt; (&#123;    type: &quot;set-message&quot;,    payload: input.getMilliseconds()  &#125;)&#125;);type Connected = &#123;  delay(input: number): Action&lt;string&gt;;  setMessage(action: Date): Action&lt;number&gt;;&#125;;export const connected: Connected = connect(new EffectModule());\n\n\n\n\n"}]